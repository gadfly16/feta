{
package feta

import (
	"bytes"
	"regexp"
	"strings"
)

func toList(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}
}

Query = sels_:Selector* tail:Tail? EOF {
	sels := toList(sels_)
	length := len(sels)
	var last selector
	if tail != nil {
		last = tail.(selector)
	}
	if length == 0 {
		return (&relSel{count: 1, next: last}), nil
	}
	for i := length - 1; i >= 0; i-- {
		sel := sels[i].(selector)
		sel.setNext(last)
		last = sel
	}
	switch sels[0].(type) {
		case *dirSel, *recurseSel:
			Log("Parser: added root op")
			sel := &rootSel{}
			sel.setNext(last)
			last = sel
		case *patternSel:
			Log("Parser: added dir op")
			sel := &dirSel{}
			sel.setNext(last)
			last = sel
	}
	return last, nil
}

// Expression nodes

Expression = first:Level_A rest_:(Or Level_A)* {
	left := first.(exprNode)
	rest := toList(rest_)
	for _, comp_ := range rest {
		comp := toList(comp_)
		node := comp[0].(*orNode)
		node.left = left
		node.right = comp[1].(exprNode)
		left = node 
	}
	return left, nil
}

Or = "||" {
	return &orNode{}, nil
}

Level_A = first:Level_B rest_:(And Level_B)* {
	left := first.(exprNode)
	rest := toList(rest_)
	for _, comp_ := range rest {
		comp := toList(comp_)
		node := comp[0].(*andNode)
		node.left = left
		node.right = comp[1].(exprNode)
		left = node 
	}
	return left, nil
}

And = "&&" {
	return &andNode{}, nil
}

Level_B = first:Level_C rest_:(Comparison Level_C)* {
	left := first.(exprNode)
	rest := toList(rest_)
	for _, comp_ := range rest {
		comp := toList(comp_)
		node := comp[0].(*compNode)
		node.left = left
		node.right = comp[1].(exprNode)
		left = node 
	}
	return left, nil
}

Comparison = ("==" / "!=" / "<=" / ">=" / "<" / ">") {
	switch string(c.text) {
	case "==":
		return &compNode{op: EQ}, nil
	case "!=":
		return &compNode{op: NEQ}, nil
	case "<=":
		return &compNode{op: LEEQ}, nil
	case ">=":
		return &compNode{op: GREQ}, nil
	case "<":
		return &compNode{op: LE}, nil
	}
	return &compNode{op: GR}, nil
}

Level_C = first:Level_D rest_:(Additive Level_D)* {
	left := first.(exprNode)
	rest := toList(rest_)
	for _, comp_ := range rest {
		comp := toList(comp_)
		node := comp[0].(*addNode)
		node.left = left
		node.right = comp[1].(exprNode)
		left = node 
	}
	return left, nil
}

Additive = ('+' / '-') {
	return &addNode{op: c.text[0]}, nil
}

Level_D = first:Level_E rest_:(Multiplicative Level_E)* {
	left := first.(exprNode)
	rest := toList(rest_)
	for _, comp_ := range rest {
		comp := toList(comp_)
		node := comp[0].(*multNode)
		node.left = left
		node.right = comp[1].(exprNode)
		left = node 
	}
	return left, nil
}

Multiplicative = ('*' / '/') {
	return &multNode{op: c.text[0]}, nil
}

Level_E = Bool / Number / String / Resolver / '(' expr:Expression ')' {
	return expr, nil
}

Resolver = first:Key '.' next:Resolver {
	Log("Parser: in compound resolver")
	return &keyNode{key: first.(string), next: next.(exprNode)}, nil
} / single:Key {
	Log("Parser: in single resolver")
	return &keyNode{key: single.(string)}, nil
}

Key = [\pL_]+ {
	return string(c.text), nil
}

Bool = "true"i {
	return fBool(true), nil
} / "false"i {
	return fBool(false), nil
}

Number = '-'? Integer ( '.' DecimalDigit+ )? Exponent? {
    n, err := strconv.ParseFloat(string(c.text), 64)
    return fNumber(n), err
}

Integer = '0' / NonZeroDecimalDigit DecimalDigit*

Exponent = 'e'i [+-]? DecimalDigit+

DecimalDigit = [0-9]

NonZeroDecimalDigit = [1-9]

String = '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
	s, err := strconv.Unquote(string(c.text))
    return fString(s), err
}

EscapedChar = [\x00-\x1f"\\]

EscapeSequence = SingleCharEscape / UnicodeEscape

SingleCharEscape = ["\\/bfnrt]

UnicodeEscape = 'u' HexDigit HexDigit HexDigit HexDigit

// Selectors

Selector = Recurse / Relative / Dir / Pattern

Tail = '@' expr:Expression {
	Log("Parser: in tail")
	return &tailSel{expr: expr.(exprNode)}, nil
} / '@' {
	return &tailSel{}, nil
}

Dir = '/' {
	Log("Parser: in 'dir'")
	return &dirSel{}, nil
}

Relative = '/'? rel_:'.'+ &OpStop {
	Log("Parser: in 'relative'")
	rel := toList(rel_)
	return &relSel{count: len(rel)}, nil
}

Recurse = '/'? "**/" {
	Log("Parser: in 'recurse'")
	return &recurseSel{}, nil
}

Pattern = [^/@]+ {
	Log("Parser: in 'pattern'")
	p := regexp.QuoteMeta(string(c.text))
	p = strings.ReplaceAll(p, "\\*", ".*")
	p = "^" + p + "$"
	op := &patternSel{rex: regexp.MustCompile(p)}
	return op, nil
}

OpStop = '/' / EOF / '@'

EOF = !.