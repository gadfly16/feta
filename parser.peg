{
package feta

import (
	"bytes"
	"regexp"
	"strings"
)

func toList(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}
}

query = ops_:operator* tail:tail? EOF
{
	ops := toList(ops_)
	length := len(ops)
	var last operator
	if tail != nil {
		last = tail.(opProducer).opProduce(nil)
	}
	if length == 0 {
		return (&relativeOp{count:1}).opProduce(last), nil
	}
	for i := length - 1; i >= 0; i-- {
		last = ops[i].(opProducer).opProduce(last)
	}
	switch ops[0].(type) {
		case *dirOp:
			Log("Parser: added root op")
			last = (&rootOp{}).opProduce(last)
		case *patternOp:
			Log("Parser: added boot op")
			last = (&dirOp{}).opProduce(last)
	}
	return last, nil
}

// Expression nodes

expression = resolver

resolver = first:key '.' next:resolver
{
	Log("Parser: in compound resolver")
	return &keyNode{key: first.(string), next: next.(exprNode)}, nil
}
/ single:key
{
	Log("Parser: in single resolver")
	return &keyNode{key: single.(string)}, nil
}

key = [\pL]+
{
	return string(c.text), nil
}

// Operators
operator = recurse / relative / dir / pattern

tail = '@' expr:expression
{
	Log("Parser: in tail operator")
	return &tailOp{expr: expr.(exprNode)}, nil
}

dir = '/'
{
	Log("Parser: in 'dir'")
	return &dirOp{}, nil
}

relative = '/'? rel_:'.'+ &opStop
{
	Log("Parser: in 'relative'")
	rel := toList(rel_)
	return &relativeOp{count: len(rel)}, nil
}

recurse = '/'? "**/"
{
	Log("Parser: in 'recurse'")
	return &recurseOp{}, nil
}

pattern = [^/@]+
{
	Log("Parser: in 'pattern'")
	p := regexp.QuoteMeta(string(c.text))
	p = strings.ReplaceAll(p, "\\*", ".*")
	p = "^" + p + "$"
	op := &patternOp{rex: regexp.MustCompile(p)}
	return op, nil
}

opStop = '/' / EOF / '@'

EOF = !.