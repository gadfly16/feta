{
package feta

import (
	"bytes"
	"regexp"
	"strings"
)

func toList(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}
}

Query = sels_:Selector* tail:Tail? EOF {
	sels := toList(sels_)
	length := len(sels)
	var last selector
	if tail != nil {
		last = tail.(selector)
	}
	if length == 0 {
		return (&relSel{count: 1, next: last}), nil
	}
	for i := length-1; i >= 0; i-- {
		sel := sels[i].(selector)
		sel.setNext(last)
		last = sel
	}
	switch first := sels[0].(type) {
		case *dirSel:
			Log("Parser: added root op")
			if first.count == 1 {
				sel := &rootSel{}
				sel.setNext(last)
				last = sel
			}
		case *patternSel:
			Log("Parser: added dir op")
			sel := &dirSel{}
			sel.setNext(last)
			last = sel
	}
	return last, nil
}

// Expression nodes

Expression = first:Level_A rest_:(Or Level_A)* {
	left := first.(expression)
	rest := toList(rest_)
	for _, comp_ := range rest {
		comp := toList(comp_)
		node := comp[0].(*orNode)
		node.left = left
		node.right = comp[1].(expression)
		left = node 
	}
	return left, nil
}

Or = "||" {
	return &orNode{}, nil
}

Level_A = first:Level_B rest_:(And Level_B)* {
	left := first.(expression)
	rest := toList(rest_)
	for _, comp_ := range rest {
		comp := toList(comp_)
		node := comp[0].(*andNode)
		node.left = left
		node.right = comp[1].(expression)
		left = node 
	}
	return left, nil
}

And = "&&" {
	return &andNode{}, nil
}

Level_B = first:Level_C rest_:(Comparison Level_C)* {
	left := first.(expression)
	rest := toList(rest_)
	for _, comp_ := range rest {
		comp := toList(comp_)
		node := comp[0].(*compNode)
		node.left = left
		node.right = comp[1].(expression)
		left = node 
	}
	return left, nil
}

Comparison = ("==" / "!=" / "<=" / ">=" / "<" / ">") {
	switch string(c.text) {
	case "==":
		return &compNode{op: EQ}, nil
	case "!=":
		return &compNode{op: NEQ}, nil
	case "<=":
		return &compNode{op: LEEQ}, nil
	case ">=":
		return &compNode{op: GREQ}, nil
	case "<":
		return &compNode{op: LE}, nil
	}
	return &compNode{op: GR}, nil
}

Level_C = first:Level_D rest_:(Additive Level_D)* {
	left := first.(expression)
	rest := toList(rest_)
	for _, comp_ := range rest {
		comp := toList(comp_)
		node := comp[0].(*addNode)
		node.left = left
		node.right = comp[1].(expression)
		left = node 
	}
	return left, nil
}

Additive = ('+' / '-') {
	return &addNode{op: c.text[0]}, nil
}

Level_D = first:Resolution rest_:(Multiplicative Resolution)* {
	left := first.(expression)
	rest := toList(rest_)
	for _, comp_ := range rest {
		comp := toList(comp_)
		node := comp[0].(*multNode)
		node.left = left
		node.right = comp[1].(expression)
		left = node 
	}
	return left, nil
}

Multiplicative = ('*' / '/') {
	return &multNode{op: c.text[0]}, nil
}

Resolution = first:Value rest_:Resolver* {
	rest := toList(rest_)
	if len(rest) == 0 {
		return first, nil
	}
	var last resolver
	for i:=len(rest)-1; i>=0; i-- {
		node := rest[i].(resolver)
		node.setNext(last)
		last = node
	}
	switch f := first.(type) {
	case *attribRes:
		f.setNext(last)
		return f, nil
	default:
		first = &valueRes{expr: first.(expression)}
	} 
	first.(resolver).setNext(last)
	return first.(expression), nil
}

Resolver = Attribute / Index

Index = '[' expr:Expression ']' {
	return &indexRes{expr: expr.(expression)}, nil
}

Attribute = '.' identifier:Identifier {
	return identifier, nil
}

Value =  Bool / Number / String / Identifier / List / Dict / '(' expr:Expression ')' {
	return expr, nil
}

List = '[' first:Expression rest_:ListElements* ']' {
	rest := toList(rest_)
	list := make([]expression, len(rest)+1)
	list[0] = first.(expression)
	for i, elm := range rest {
		list[i+1] = elm.(expression)
	}
	return fList(list), nil
}

ListElements = ',' expr:Expression {
	return expr, nil
}

Dict = '{' first_:(Identifier ':' Expression) rest_:(',' Identifier ':' Expression)* '}' {
	first := toList(first_)
	rest := toList(rest_)
	dict := make(map[string]expression)
	dict[first[0].(*attribRes).identifier] = first[2].(expression)
	for _, kvp_ := range rest {
		kvp := toList(kvp_)
		dict[kvp[1].(*attribRes).identifier] = kvp[3].(expression)
	}
	return fDict(dict), nil
}

Identifier = [\pL_]+ {
	return &attribRes{identifier: string(c.text)}, nil
}

Bool = "true"i {
	return fBool(true), nil
} / "false"i {
	return fBool(false), nil
}

Number = '-'? Integer ( '.' DecimalDigit+ )? Exponent? {
    n, err := strconv.ParseFloat(string(c.text), 64)
    return fNumber(n), err
}

Integer = '0' / NonZeroDecimalDigit DecimalDigit*

Exponent = 'e'i [+-]? DecimalDigit+

DecimalDigit = [0-9]

NonZeroDecimalDigit = [1-9]

String = '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
	s, err := strconv.Unquote(string(c.text))
    return fString(s), err
}

EscapedChar = [\x00-\x1f"\\]

EscapeSequence = SingleCharEscape / UnicodeEscape

SingleCharEscape = ["\\/bfnrt]

UnicodeEscape = 'u' HexDigit HexDigit HexDigit HexDigit

HexDigit = [0-9a-f]i

// Selectors

Selector = Recurse / Relative / Dir / Pattern / Filter

Tail = '@' expr:Expression {
	Log("Parser: in tail")
	return &tailSel{expr: expr.(expression)}, nil
} / '@' {
	return &tailSel{}, nil
}

Dir = dirs_:'/'+ {
	return &dirSel{count: len(toList(dirs_))}, nil
}

Filter = "(?" expr:Expression ')' {
	return &filterSel{expr: expr.(expression)}, nil
}

Relative = rel_:'.'+ &OpStop {
	rel := toList(rel_)
	return &relSel{count: len(rel)}, nil
}

Recurse = "**/" {
	Log("Parser: in 'recurse'")
	return &recurseSel{}, nil
}

Pattern = [^/@(]+ {
	Log("Parser: in 'pattern'")
	p := regexp.QuoteMeta(string(c.text))
	p = strings.ReplaceAll(p, "\\*", ".*")
	p = "^" + p + "$"
	op := &patternSel{rex: regexp.MustCompile(p)}
	return op, nil
}

OpStop = '/' / EOF / '@'

EOF = !.