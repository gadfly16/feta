{
package feta

import (
	"bytes"
	"regexp"
	"strings"
)

func toList(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}
}

selector = ops_:operator+ EOF
{
	ops := toList(ops_)
	length := len(ops)
	last := ops[length-1].(opProducer).opProduce(nil)
	for i := range ops {
		if length-i-2 == -1 {
			break
		}
		last = ops[length-i-2].(opProducer).opProduce(last)
	}
	switch ops[0].(type) {
		case *dirOp:
			Log("Parser: added root op")
			last = (&rootOp{}).opProduce(last)
		case *patternOp:
			Log("Parser: added boot op")
			last = (&bootOp{}).opProduce(last)
	}
	return last, nil
}

operator = recurse / relative / dir / pattern

dir = '/'
{
	Log("Parser: in 'dir'")
	return &dirOp{}, nil
}

relative = '/'? rel_:'.'+ &opStop
{
	Log("Parser: in 'relative'")
	rel := toList(rel_)
	return &relativeOp{count: len(rel)}, nil
}

recurse = "**/"
{
	Log("Parser: in 'recurse'")
	return &recurseOp{}, nil
}

pattern = [^/]+
{
	Log("Parser: in 'pattern'")
	p := regexp.QuoteMeta(string(c.text))
	p = strings.ReplaceAll(p, "\\*", ".*")
	p = "^" + p + "$"
	op := &patternOp{rex: regexp.MustCompile(p)}
	return op, nil
}

opStop = '/' / EOF

EOF = !.