{
package feta

import (
	"bytes"
	"regexp"
	"strings"
)

func toList(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}
}

Query = ops_:Operator* tail:Tail? EOF {
	ops := toList(ops_)
	length := len(ops)
	var last operator
	if tail != nil {
		last = tail.(opProducer).opProduce(nil)
	}
	if length == 0 {
		return (&relativeOp{count:1}).opProduce(last), nil
	}
	for i := length - 1; i >= 0; i-- {
		last = ops[i].(opProducer).opProduce(last)
	}
	switch ops[0].(type) {
		case *dirOp:
			Log("Parser: added root op")
			last = (&rootOp{}).opProduce(last)
		case *patternOp:
			Log("Parser: added dir op")
			last = (&dirOp{}).opProduce(last)
	}
	return last, nil
}

// Expression nodes

Expression = first:Level_A rest_:(Comparison Level_A)* {
	left := first.(exprNode)
	rest := toList(rest_)
	for _, comp_ := range rest {
		comp := toList(comp_)
		node := comp[0].(*compNode)
		node.left = left
		node.right = comp[1].(exprNode)
		left = node 
	}
	return left, nil
}

Comparison = ("==" / "<=" / ">=" / "<" / ">") {
	switch string(c.text) {
	case "==":
		Log("Parser: Egual comparison")
		return &compNode{op: EQ}, nil
	case "<=":
		return &compNode{op: LEEQ}, nil
	case ">=":
		return &compNode{op: GREQ}, nil
	case "<":
		return &compNode{op: LE}, nil
	}
	return &compNode{op: GR}, nil
}

Level_A = first:Level_B rest_:(Additive Level_B)* {
	left := first.(exprNode)
	rest := toList(rest_)
	for _, comp_ := range rest {
		comp := toList(comp_)
		node := comp[0].(*addNode)
		node.left = left
		node.right = comp[1].(exprNode)
		left = node 
	}
	return left, nil
}

Additive = ('+' / '-') {
	return &addNode{op: c.text[0]}, nil
}

Level_B = first:Level_C rest_:(Multiplicative Level_C)* {
	left := first.(exprNode)
	rest := toList(rest_)
	for _, comp_ := range rest {
		comp := toList(comp_)
		node := comp[0].(*multNode)
		node.left = left
		node.right = comp[1].(exprNode)
		left = node 
	}
	return left, nil
}

Multiplicative = ('*' / '/') {
	return &multNode{op: c.text[0]}, nil
}

Level_C = Number / String / Resolver / '(' expr:Expression ')' {
	return expr, nil
}

Resolver = first:Key '.' next:Resolver {
	Log("Parser: in compound resolver")
	return &keyNode{key: first.(string), next: next.(exprNode)}, nil
} / single:Key {
	Log("Parser: in single resolver")
	return &keyNode{key: single.(string)}, nil
}

Key = [\pL]+ {
	return string(c.text), nil
}

Number = '-'? Integer ( '.' DecimalDigit+ )? Exponent? {
    n, err := strconv.ParseFloat(string(c.text), 64)
    return &numberNode{value: fNumber(n)}, err
}

Integer = '0' / NonZeroDecimalDigit DecimalDigit*

Exponent = 'e'i [+-]? DecimalDigit+

DecimalDigit = [0-9]

NonZeroDecimalDigit = [1-9]

String = '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
    // TODO : the forward slash (solidus) is not a valid escape in Go, it will
    // fail if there's one in the string
	s, err := strconv.Unquote(string(c.text))
    return &stringNode{value: fString(s)}, err
}

EscapedChar = [\x00-\x1f"\\]

EscapeSequence = SingleCharEscape / UnicodeEscape

SingleCharEscape = ["\\/bfnrt]

UnicodeEscape = 'u' HexDigit HexDigit HexDigit HexDigit

// Operators

Operator = Recurse / Relative / Dir / Pattern

Tail = '@' expr:Expression {
	Log("Parser: in tail operator")
	return &tailOp{expr: expr.(exprNode)}, nil
} / '@' {
	return &tailOp{}, nil
}

Dir = '/' {
	Log("Parser: in 'dir'")
	return &dirOp{}, nil
}

Relative = '/'? rel_:'.'+ &OpStop {
	Log("Parser: in 'relative'")
	rel := toList(rel_)
	return &relativeOp{count: len(rel)}, nil
}

Recurse = '/'? "**/" {
	Log("Parser: in 'recurse'")
	return &recurseOp{}, nil
}

Pattern = [^/@]+ {
	Log("Parser: in 'pattern'")
	p := regexp.QuoteMeta(string(c.text))
	p = strings.ReplaceAll(p, "\\*", ".*")
	p = "^" + p + "$"
	op := &patternOp{rex: regexp.MustCompile(p)}
	return op, nil
}

OpStop = '/' / EOF / '@'

EOF = !.